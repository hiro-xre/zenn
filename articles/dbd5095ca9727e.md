---
title: Vue.js のスタイルガイドを簡単に紹介する
emoji: "⚠️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["vue", "nuxt"]
published: false
---

# はじめに
Vue.js （以降 Vue と記します） を書きはじめて 2 年が経ちました。本記事では、 お世話になっているスタイルガイドを簡単に紹介します。
どなたかの参考になれば幸いです。ご指摘やアドバイスもお待ちしています。

# 対象読者
* 普段 Vue を書いている方
* これから Vue を書こうと思っている方
* Vue のスタイルガイドをはじめて知る方

# 前提
Composition API でのコーディングとします。

# スタイルガイド
https://ja.vuejs.org/style-guide/

公式が提供している Vue の参考書みたいなものです。「こんな感じで書くといいよ」や「これは避けようね」などの具体例が記載されています。基本はこのスタイルガイドに沿ってコーディングしていくのがよいです。


## コンポーネントファイルの命名
コンポーネントファイルの命名については、スタイルガイドにいくつか推奨事項があります。
* （必須）実装するコンポーネントの責務を踏まえ、複数単語かつパスカルケースのコンポーネント名となるようにする。
* （推奨）汎用的なベースとなるコンポーネントには特定のプレフィックス（`Base`、`App`、`V` など）ではじめる。
* （推奨）親コンポーネントと密結合になる子コンポーネントは、親コンポーネントの名前をプレフィックスに含める。
* （推奨）複数単語の並び順は責務の主題となる単語からはじめ、説明的な単語を続ける。

基本はこれらを満たす命名にします。

https://ja.vuejs.org/style-guide/rules-essential.html#use-multi-word-component-names

https://ja.vuejs.org/style-guide/rules-strongly-recommended.html#single-file-component-filename-casing

https://ja.vuejs.org/style-guide/rules-strongly-recommended.html#base-component-names

https://ja.vuejs.org/style-guide/rules-strongly-recommended.html#tightly-coupled-component-names

https://ja.vuejs.org/style-guide/rules-strongly-recommended.html#order-of-words-in-component-names

## コンポーネント/インスタンスオプションの順番
単一ファイルよりもプロダクト全体で統一されているとよいことですが、コーディングの順序がある程度決められています。スタイルガイドにはオプションの順序について記載がありますが、`<script setup>` タグを用いたコーディングでも参考になります。

* `provide` / `inject` や `store` 情報
* `props` / `emits`
* `state`
* `computed`
* 関数処理（Options API における `methods`オプションに相当する処理）
* `watch`
* ライフサイクルイベント

順序の理由は感覚的なものもありますが、データの流れが追いやすいと考えています。
1. どのようなグローバルな情報が必要で
2. 親からどのようなデータを受け取って
3. このファイルではどのようなデータを管理して
4. どのような参照情報を持って
5. どのような処理があって
6. 処理がどのようなタイミングで行われるか

このようなイメージを持ってコードを書いていますし、コードを読んでいます。

https://ja.vuejs.org/style-guide/rules-recommended.html#component-instance-options-order

## コード間の空白行
これがスタイルガイドに記載されていることが素晴らしいです。視覚的な可読性を上げるためにも、適宜空白行を設けています。
筆者は以下を意識しています。

* `props` ・ `state` ・ `computed` など概念が異なるものには空白行を設ける
* `computed` などのまとまりの中でも、責務が異なるものには空白行を設ける
  * `computed` の参照先となる `state` が異なる場合は空白行を設ける

https://ja.vuejs.org/style-guide/rules-recommended.html#empty-lines-in-component-instance-options

## 単一ファイルコンポーネント内でのコンポーネント名
基本的に `<MyComponent/>` のようにパスカルケースを使用します。それだけです。

https://ja.vuejs.org/style-guide/rules-strongly-recommended.html#component-name-casing-in-templates

## 単一ファイルコンポーネントの `<script>` `<template>` `<style>` タグの順序
単一ファイルコンポーネント（SFC）では、`<script>`, `<template>`, `<style>` タグの順番はプロダクト内で一定にします。
筆者は[ドキュメント](https://ja.vuejs.org/guide/scaling-up/sfc.html#single-file-components)同様 `<script>`, `<template>`, `<style>` の順に書いています。
なお、`<style>` タグは使用しない場合があるため、常に最後にする必要があります。

https://ja.vuejs.org/style-guide/rules-recommended.html#single-file-component-top-level-element-order

## ディレクティブの短縮記法
* 常に使う（`<input :value="newTodoText">` など）
* 常に使わない（`<input v-bind:value="newTodoText">` など）

ディレクティブの短縮記法は上記を守ります。Vue を書きはじめたばかりの頃は省略記法に慣れませんが、慣れてくるとコードがスッキリして読みやすいです。

https://ja.vuejs.org/style-guide/rules-strongly-recommended.html#directive-shorthands

## キー付きの v-for を使用する
Linter を使用していれば無意識で対応できますが、`v-for` には必ずキーを付与します。なぜキーが必要なのかスタイルガイドに詳細な理由が記載されていますが、簡潔に述べるとパフォーマンスが安定するからです。

https://ja.vuejs.org/style-guide/rules-essential.html#use-keyed-v-for

以上がスタイルガイドに記載されているものです。これらのガイドを遵守し、誰もが読みやすいコードを意識してみましょう。

# おまけ（個人的スタイルガイド）
以下は個人的に意識しているものの中から、効果的かつ簡単なものを 2 つ記載しています。

## テンプレート部を簡潔にする
テンプレート（`<template>`）部に記すロジックは**最低限**にします。
これは、UI（`<template>`）と処理（`<script>`）の関心を明確にわける意図があります。
例えば以下のコードがあるとします。
```vue:BeforeCode.vue
<script setup lang="ts">
import { ref } from "vue";

const value1 = ref(0);
const value2 = ref(0);

const isActive = ref(true);
const hasError = ref(false);
...
</script>

<template>
  <div
    v-if="value1 === 0 && value2 === 0"
    :class="{ active: isActive, 'text-danger': hasError }"
  >
    条件によって表示・非表示を分けます。
  </div>
</template>
```

上記のコードは以下にします。
```vue:AfterCode.vue
<script setup lang="ts">
import { ref, computed } from "vue";

const value1 = ref(0);
const value2 = ref(0);

const isActive = ref(true);
const hasError = ref(false);

const isDisplayText = computed(() => {
  return value1.value === 0 && value2.value === 0
});

const classObject = computed(() => ({
  active: isActive.value,
  'text-danger': hasError.value
}));
...
</script>

<template>
  <div
    v-if="isDisplayText"
    :class="classObject"
  >
    条件によって表示・非表示を分けます。
  </div>
</template>
```

テンプレート部に書いていた `value1 === 0 && value2 === 0` という条件を、`isDisplayText` という `computed` に置き換えています。また、クラスも `computed` に切り出しています。
こうすることで以下の利点があります。
* テンプレート部が簡潔になり、DOM 構造を視覚的に把握しやすい
* 条件を変数として命名することで、どのような条件なのかわかりやすい
* 条件が肥大化しても、テンプレート部が肥大化しない

もちろん、ある程度（感覚的な表現ですが）のロジックはテンプレート部に記載してもいいです。

## `<template>` に `v-if` を適用する
いくつかの要素の表示制御を行う場合は `<template>` に `v-if` を適用します。
例えば以下のコードがあるとします。
```html:BeforeCode.vue
<template>
  <div v-if="value === 0">
    条件によって表示・非表示を分けます。
  </div>
  <div v-if="value === 0">
    条件によって表示・非表示を分けます？
  </div>
  <div v-if="value === 0">
    条件によって表示・非表示を分けます！
  </div>
</template>
```

上記のコードは以下にします。
```html:AfterCode.vue
<template>
  <template v-if="value === 0">
    <div>条件によって表示・非表示を分けます。</div>
    <div>条件によって表示・非表示を分けます？</div>
    <div>条件によって表示・非表示を分けます！</div>
  </template>
</template>
```

`<template>` は**レンダリングされない要素**なので、ラッパーとしてしばし役に立ちます。
